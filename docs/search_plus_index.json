{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"Flink/work.html":{"url":"Flink/work.html","title":"Flink","keywords":"","body":"任务调度 1. Flink 架构 2. 任务提交流程 Flink任务提交后，Client向HDFS上传Flink的Jar包和配置，之后向Yarn ResourceManager提交任务，ResourceManager分配Container资源并通知对应的NodeManager启动ApplicationMaster，ApplicationMaster启动后加载Flink的Jar包和配置构建环境，然后启动JobManager，之后ApplicationMaster向ResourceManager申请资源启动TaskManager，ResourceManager分配Container资源后，由ApplicationMaster通知资源所在节点的NodeManager启动TaskManager，NodeManager加载Flink的Jar包和配置构建环境并启动TaskManager，TaskManager启动后向JobManager发送心跳包，并等待JobManager向其分配任务。 3. 作业调度 4. Flink 执行图 在 Flink 中的执行图可以分为四层：StreamGraph -> JobGraph -> ExecutionGraph -> 物理执行图 StreamGraph：Stream API 编写的代码生成的最初的图。用来表示程序的拓扑结构。可以调用 env.getExecutionPlan() 输出json串，将该 JSON 串粘贴到 http://flink.apache.org/visualizer/ 可视化该执行图。 JobGraph：StreamGraph 经过优化后生成了 JobGraph，提交给 JobManager 的数据结构。主要的优化为，将多个符合条件的节点 chain 在一起作为一个节点，这样可以减少数据在节点之间流动所需要的序列化/反序列化/传输消耗。 ExecutionGraph：JobManager 根据 JobGraph 生成 ExecutionGraph。ExecutionGraph 是 JobGraph 的并行化版本，是调度层最核心的数据结构。 物理执行图：JobManager 根据 ExecutionGraph 对 Job 进行调度后，在各个TaskManager 上部署 Task 后形成的“图”，并不是一个具体的数据结构。 "},"Flink/solt.html":{"url":"Flink/solt.html","title":"并行度","keywords":"","body":"parallelism 设置方式： 可以通过修改$FLINK_HOME/conf/flink-conf.yaml文件的方式更改并行度 可以通过设置$FLINK_HOME/bin/flink 的-p参数修改并行度 可以通过设置executionEnvironmentk的方法修改并行度 可以通过设置flink的编程API修改过并行度 优先级：api>env>p>file "}}